package com.kotakotik.kotalin.build.gen

import com.kotakotik.kotalin.build.genDir
import com.kotakotik.kotalin.build.primitives
import org.gradle.api.Project

internal fun Project.genPeekingIterators() {
    for(primitive in primitives) {
        file("$genDir/peeking/Peeking${primitive.name}Iterator.kt").writeText("""
                // Automatically generated by the task generatePeekingIters
                
                @file:JvmMultifileClass
                @file:JvmName("PeekingIteratorKt")
                
                package com.kotakotik.kotalin.peeking
                
                ${if(primitive.customIterator) "import com.kotakotik.kotalin.iterator.${primitive.name}Iterator" else ""}
                import kotlin.jvm.JvmMultifileClass
                import kotlin.jvm.JvmName
                
                /**
                 * A [PeekingIterator] that iterates over [${primitive.name}]s without boxing
                 * @see PeekingIterator, ${primitive.name}Iterator
                */
                class Peeking${primitive.name}Iterator(private val innerIter: ${primitive.name}Iterator) : ${primitive.name}Iterator(), PeekingIterator<${primitive.name}> {
                    private var peeked: ${primitive.name} = ${primitive.zero}
                    private var hasPeeked = false
                    
                    /**
                     * Peeks the next element without boxing
                     * @see peek
                    */
                    fun peek${primitive.name}(): ${primitive.name} {
                        if(!hasPeeked) {
                            hasPeeked = true
                            peeked = innerIter.next${primitive.name}()
                        }
                        return peeked
                    }
                    
                    override fun peek() = peek${primitive.name}()
                    
                    override fun next${primitive.name}() = if(hasPeeked) {
                        hasPeeked = false
                        peeked
                    } else {
                        innerIter.next${primitive.name}()
                    }
                    
                    override fun hasNext() =
                        hasPeeked || innerIter.hasNext()
                }
                
                /**
                 * Creates a new [Peeking${primitive.name}Iterator] wrapping around this iterator
                 *
                 * @see PeekingIterator, Peeking${primitive.name}Iterator
                 */
                fun ${primitive.name}Iterator.peeking() =
                    Peeking${primitive.name}Iterator(this)
        """.trimIndent())
    }
}